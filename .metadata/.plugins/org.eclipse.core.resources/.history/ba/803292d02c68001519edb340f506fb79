/*
 * Copyright (c) 2000-2016 Fachhochschule Nordwestschweiz (FHNW)
 * All Rights Reserved. 
 */

package jdraw.std;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import jdraw.framework.DrawCommandHandler;
import jdraw.framework.DrawModel;
import jdraw.framework.DrawModelEvent;
import jdraw.framework.DrawModelListener;
import jdraw.framework.Figure;
import jdraw.framework.FigureEvent;
import jdraw.framework.FigureListener;

/**
 * Provide a standard behavior for the drawing model. This class initially does
 * not implement the methods in a proper way. It is part of the course
 * assignments to do so.
 * 
 * @author TODO add your name here
 *
 */
public class StdDrawModel implements DrawModel, FigureListener {

	private List<DrawModelListener> listeners = new LinkedList<>();
	private List<Figure> figures = new LinkedList<>();

	@Override
	public void addFigure(Figure f) {
	
		if (f != null && !figures.contains(f)) {
		f.addFigureListener(this);

		figures.add(f);
		//hier erfährt view, dass figure hinzugefügt wurde
		update(new DrawModelEvent(this, f, DrawModelEvent.Type.FIGURE_ADDED));
		}

	}

	@Override
	public Iterable<Figure> getFigures() {

		System.out.println("StdDrawModel.getFigures has to be implemented");
		return figures; // Only guarantees, that the application starts -- has
						// to be replaced !!!
	}

	@Override
	public void removeFigure(Figure f) {

		if(figures.remove(f)){
		update(new DrawModelEvent(this, f, DrawModelEvent.Type.FIGURE_REMOVED));
		f.removeFigureListener(this);
		}
	}

	@Override
	public void addModelChangeListener(DrawModelListener listener) {

		listeners.add(listener);
	}

	@Override
	public void removeModelChangeListener(DrawModelListener listener) {

		listeners.remove(listener);
	}

	/**
	 * The draw command handler. Initialized here with a dummy implementation.
	 */
	// TODO initialize with your implementation of the undo/redo-assignment.
	private DrawCommandHandler handler = new EmptyDrawCommandHandler();

	/**
	 * Retrieve the draw command handler in use.
	 * 
	 * @return the draw command handler.
	 */
	public DrawCommandHandler getDrawCommandHandler() {
		return handler;
	}

	@Override
	public void setFigureIndex(Figure f, int index) {
	
		if(f != null){
			figures.set(index, f);
			update(new DrawModelEvent(this, f, DrawModelEvent.Type.DRAWING_CHANGED));
		}
	}

	@Override
	public void removeAllFigures() {
		
		//Iterator mit Figures
		Iterator<Figure> it = figures.iterator();
		//So lange es ein nächstes Element in der Figurenliste gibt...
		while(it.hasNext()){
			//...weise dieses Element f zu...
			Figure f = it.next();
			//...entferne das Element aus der Liste von Figures...
			it.remove();
			//...löse ein neues Event aus (nämlich dass die Zeichnung gelöscht wurde)...
			update(new DrawModelEvent(this, f, DrawModelEvent.Type.DRAWING_CLEARED));
			//...und entferne f aus der Liste der FigureListener
			f.removeFigureListener(this);
		}
	}

	public void update(DrawModelEvent e) {
		for (DrawModelListener l : listeners) {
			l.modelChanged(e);
		}
	}

	@Override
	public void figureChanged(FigureEvent e) {
	
		//???
		update(new DrawModelEvent(this, e.getFigure(), DrawModelEvent.Type.FIGURE_CHANGED));
	}

}
